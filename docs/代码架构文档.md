# RISC-V 模拟器代码架构文档

## 总体架构

### 设计理念
RISC-V模拟器采用**模块化分层架构**，每个组件职责单一、接口清晰。设计遵循以下原则：
- **职责分离**: 每个类专注于特定功能
- **接口抽象**: 组件间通过明确的接口通信
- **可扩展性**: 支持RISC-V扩展指令集
- **可测试性**: 便于单元测试和集成测试

### 架构层次

```
┌─────────────────────────────────────────────────────────────┐
│                        用户接口层                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │    main     │  │  调试工具    │  │      测试套件         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                        模拟器控制层                           │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                   Simulator                             ││
│  │    • 程序加载管理                                         ││
│  │    • 执行控制                                            ││
│  │    • 组件协调                                            ││
│  │    • 状态查询                                            ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                        核心执行层                              │
│  ┌─────────────┐              ┌─────────────────────────────┐ │
│  │     CPU     │◄────────────►│          Memory             │ │
│  │  • 指令执行  │              │  • 线性地址空间              │ │
│  │  • 寄存器   │              │  • 字节序处理                │ │
│  │  • 状态机   │              │  • 边界检查                  │ │
│  └─────────────┘              └─────────────────────────────┘ │
│         │                                    │                │
│  ┌─────────────┐              ┌─────────────────────────────┐ │
│  │   Decoder   │              │     SyscallHandler          │ │
│  │  • 指令解码  │              │  • 系统调用处理              │ │
│  │  • 格式识别  │              │  • POSIX兼容                │ │
│  │  • 扩展支持  │              │  • I/O重定向                │ │
│  └─────────────┘              └─────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                        基础服务层                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │     ALU     │  │  ElfLoader  │  │      异常处理        │  │
│  │  • 运算操作  │  │  • 文件解析  │  │  • 错误恢复          │  │
│  │  • 比较运算  │  │  • 内存映射  │  │  • 状态报告          │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## 组件详细设计

### 1. Simulator（模拟器控制器）

#### 职责
- **程序生命周期管理**: 加载、运行、重置
- **组件协调**: 统一管理CPU和Memory
- **接口适配**: 为用户提供简化的高层接口
- **状态监控**: 提供执行状态和统计信息

#### 设计模式
- **外观模式**: 隐藏内部复杂性，提供统一接口
- **组合模式**: 聚合CPU和Memory组件

#### 关键数据流
```cpp
// 程序加载流程
loadRiscvProgram() → loadBinaryFile() → Memory::loadProgram() → CPU::reset()

// 执行控制流程  
run() → CPU::run() → CPU::step() → fetch-decode-execute循环
```

#### 内存管理策略
- 使用智能指针管理Memory对象生命周期
- CPU通过共享指针访问内存，避免数据拷贝
- 统一的内存大小配置和边界检查

### 2. CPU（处理器核心）

#### 职责
- **指令执行**: 实现完整的取指-译码-执行循环
- **状态管理**: 维护寄存器和程序计数器状态
- **扩展支持**: 模块化的指令集扩展机制
- **异常处理**: 非法指令和内存异常处理

#### 核心状态机
```
初始状态 → 取指 → 解码 → 执行 → 更新PC → 检查停机条件
    ↑                                              ↓
    └─────────────── 继续执行 ←──────────────────────┘
```

#### 指令执行架构
```cpp
class CPU {
private:
    // 状态寄存器
    std::array<uint32_t, 32> registers_;      // 通用寄存器
    std::array<uint32_t, 32> fp_registers_;   // 浮点寄存器
    uint32_t pc_;                             // 程序计数器
    
    // 执行组件
    Decoder decoder_;                         // 指令解码器
    std::unique_ptr<SyscallHandler> syscall_handler_;
    
    // 执行引擎
    void executeRType(const DecodedInstruction& inst);
    void executeIType(const DecodedInstruction& inst);
    // ...其他指令类型执行器
};
```

#### 扩展指令机制
- **M扩展**: 独立的`executeMExtension()`函数
- **F扩展**: 专门的浮点寄存器和`executeFPExtension()`
- **C扩展**: 解码器层面的透明支持

#### 性能优化
- 指令计数限制防止无限循环
- 高频操作内联优化
- 分支预测简化（总是不跳转）

### 3. Memory（内存管理器）

#### 职责
- **地址空间管理**: 线性64位地址空间
- **数据访问**: 支持字节、半字、字、双字（64位）访问
- **字节序处理**: 统一的小端序实现
- **边界检查**: 防止内存越界访问

#### 内存布局策略
```
0x00000000  ┌─────────────────────────────────────┐
            │              保留区域                 │
0x00001000  ├─────────────────────────────────────┤
            │                                     │
            │              程序代码                 │
            │                                     │
            ├─────────────────────────────────────┤
            │              程序数据                 │
            ├─────────────────────────────────────┤
            │                ...                   │
            ├─────────────────────────────────────┤
            │              栈区域                   │
内存顶部     └─────────────────────────────────────┘
```

#### 指令取指机制
```cpp
Instruction fetchInstruction(Address addr) const {
    // 1. 检查2字节对齐
    if (addr % 2 != 0) throw MemoryException(...);
    
    // 2. 读取前16位
    uint16_t first_half = readHalfWord(addr);
    
    // 3. 判断指令长度
    if ((first_half & 0x03) == 0x03) {
        // 标准32位指令: 读取后16位
        uint16_t second_half = readHalfWord(addr + 2);
        return first_half | (second_half << 16);
    } else {
        // 16位压缩指令
        return first_half;
    }
}
```

#### 内存访问模式
- **直接访问**: 通过std::vector实现，O(1)时间复杂度
- **边界检查**: 每次访问都验证地址范围
- **字节序一致性**: 所有多字节访问使用统一的小端序

### 4. Decoder（指令解码器）

#### 职责
- **指令识别**: 区分16位压缩和32位标准指令
- **字段提取**: 解析操作码、寄存器、立即数
- **格式转换**: 将压缩指令扩展为标准格式
- **扩展验证**: 检查指令是否被支持

#### 解码流水线
```
指令输入 → 长度检测 → 字段提取 → 立即数处理 → 验证检查 → 输出结构
```

#### 压缩指令展开策略
```cpp
// C.ADDI 示例: 1001 imm[5] rd imm[4:0] 01
// 展开为: imm[11:0] rs1 000 rd 0010011 (ADDI)

DecodedInstruction expandCompressedInstruction(uint16_t instruction) {
    uint8_t op = instruction & 0x03;        // 操作象限
    uint8_t funct3 = (instruction >> 13) & 0x07;  // 功能码
    
    switch (op) {
        case 0x01:  // Quadrant 1
            switch (funct3) {
                case 0x00:  // C.ADDI
                    // 提取字段并构造标准I型指令
                    break;
            }
    }
}
```

#### 立即数符号扩展
- **算法**: 使用位操作实现高效符号扩展
- **类型安全**: 明确区分有符号和无符号操作
- **范围检查**: 验证立即数是否在有效范围内

### 5. ALU（算术逻辑单元）

#### 职责
- **基础运算**: 加减法、逻辑运算、移位操作
- **比较运算**: 有符号/无符号比较
- **类型转换**: 符号扩展和截断
- **运算优化**: 高效的位操作实现

#### 运算分类
```cpp
// 算术运算组（RV64I 基础）
uint64_t add(uint64_t a, uint64_t b);
uint64_t sub(uint64_t a, uint64_t b);

// 逻辑运算组
uint64_t and_(uint64_t a, uint64_t b);
uint64_t or_(uint64_t a, uint64_t b);
uint64_t xor_(uint64_t a, uint64_t b);

// 移位运算组
uint64_t sll(uint64_t a, uint64_t shamt);  // 逻辑左移
uint64_t srl(uint64_t a, uint64_t shamt);  // 逻辑右移
uint64_t sra(uint64_t a, uint64_t shamt);  // 算术右移

// 比较运算组
bool slt(int64_t a, int64_t b);       // 有符号比较
bool sltu(uint64_t a, uint64_t b);    // 无符号比较

// 注：W 类指令（如 ADDW/SUBW）在执行后对结果做 32 位截断与符号扩展
```

#### 移位操作优化
- 自动取移位量的低6位（模64操作）
- 算术右移使用有符号数类型转换
- 避免未定义行为的移位操作

### 6. SyscallHandler（系统调用处理器）

#### 职责
- **ABI兼容**: 实现RISC-V Linux ABI规范
- **I/O重定向**: 处理标准输入输出
- **资源管理**: 简化的内存和文件管理
- **测试支持**: 为riscv-tests提供专门支持

#### 系统调用映射
```cpp
// RISC-V Linux ABI
constexpr uint32_t SYS_READ = 63;    // 读取
constexpr uint32_t SYS_WRITE = 64;   // 写入  
constexpr uint32_t SYS_EXIT = 93;    // 退出
constexpr uint32_t SYS_BRK = 214;    // 设置程序断点
```

#### 参数传递约定
- **系统调用号**: a7寄存器 (x17)
- **参数**: a0-a6寄存器 (x10-x16)
- **返回值**: a0寄存器 (x10)
- **错误码**: 负数表示错误

#### I/O处理机制
```cpp
void handleWrite(CPU* cpu) {
    uint64_t fd = cpu->getRegister(10);       // 文件描述符（64位寄存器）
    uint64_t bufAddr = cpu->getRegister(11);  // 缓冲区地址
    uint64_t count = cpu->getRegister(12);    // 字节数

    for (uint64_t i = 0; i < count; i++) {
        char c = memory_->readByte(bufAddr + i);
        std::cout << c;
    }

    cpu->setRegister(10, count);  // 返回写入字节数
}
```

### 7. ElfLoader（ELF文件加载器）

#### 职责
- **格式解析**: 解析ELF文件头和程序头表
- **内存映射**: 将程序段加载到正确的内存位置
- **权限设置**: 处理段的读写执行权限
- **BSS初始化**: 零初始化未初始化数据段

#### ELF解析流程
```
文件读取 → 头部验证 → 程序头解析 → 段数据加载 → 权限设置 → 入口点设置
```

#### 内存映射策略
```cpp
// 加载可执行段
if (ph.p_type == PT_LOAD) {
    // 1. 加载文件数据
    memory->loadProgram(segment.data, segment.virtualAddr);
    
    // 2. 零初始化BSS区域
    if (segment.memorySize > segment.fileSize) {
        for (size_t i = segment.fileSize; i < segment.memorySize; i++) {
            memory->writeByte(segment.virtualAddr + i, 0);
        }
    }
}
```

## 数据流架构

### 程序执行流
```
用户程序 → ElfLoader → Memory ← CPU → Decoder
                                ↓
                        SyscallHandler ← ALU
```

### 指令执行流
```
Memory::fetchInstruction() → Decoder::decode() → CPU::execute*Type() → ALU/Memory操作
```

### 系统调用流
```
ECALL指令 → CPU::handleEcall() → SyscallHandler::handleSyscall() → 具体处理函数
```

## 扩展机制设计

### 指令集扩展架构
```cpp
enum class Extension : uint32_t {
    I = 0x1,     // 基础整数
    M = 0x2,     // 乘除法
    A = 0x4,     // 原子操作
    F = 0x8,     // 单精度浮点
    D = 0x10,    // 双精度浮点
    C = 0x20     // 压缩指令
};
```

## 乱序执行（OOO）架构概览

项目同时实现顺序（In-Order）与乱序（Out-of-Order，默认）两种 CPU：
- 顺序 CPU：`src/cpu/inorder/cpu.cpp`
- 乱序 CPU：`src/cpu/ooo/`（含 ROB、RS、StoreBuffer、寄存器重命名与多级流水）

OOO 主要组件与职责：
- 寄存器重命名：`register_rename.*`，消除 WAR/WAW 依赖，提供物理寄存器映射
- 保留站（RS）：`reservation_station.*`，指令就绪判断与调度
- 重排序缓冲（ROB）：`reorder_buffer.*`，提交一致性、异常恢复与提交顺序保证
- 存储缓冲：`store_buffer.*`，Store-Load 前递与内存依赖处理
- 分阶段流水：`stages/{fetch,decode,issue,execute,writeback,commit}.cpp`

运行选择：`--ooo`（默认）或 `--in-order`。推荐在 riscv-tests 下使用 `-m 2164260864` 以覆盖 64 位地址范围。

### 扩展检查机制
```cpp
void validateInstruction(const DecodedInstruction& decoded, uint32_t enabled_extensions) {
    if (decoded.opcode == Opcode::OP && decoded.funct7 == Funct7::M_EXT) {
        if (!isExtensionEnabled(enabled_extensions, Extension::M)) {
            throw IllegalInstructionException("M扩展指令未启用");
        }
    }
}
```

### 新扩展添加步骤
1. 在`Extension`枚举中添加新标志
2. 在`Decoder`中添加识别逻辑
3. 在`CPU`中添加执行函数
4. 在`validateInstruction`中添加检查
5. 更新测试用例

## 错误处理架构

### 异常层次结构
```
SimulatorException (基类)
├── IllegalInstructionException (非法指令)
├── MemoryException (内存错误)
└── 其他具体异常...
```

### 错误恢复策略
- **指令级错误**: 抛出异常，停止执行
- **系统调用错误**: 设置错误码，继续执行
- **内存错误**: 立即停机，保护系统

### 调试信息
- **详细异常信息**: 包含出错地址和上下文
- **状态转储**: 寄存器和内存状态快照
- **执行统计**: 指令数量和性能指标

## 性能优化策略

### 内存访问优化
- **直接索引**: 使用std::vector避免动态分配
- **边界检查优化**: 在调试模式下可选择禁用
- **缓存友好**: 线性内存布局提高缓存命中率

### 指令执行优化
- **分支预测**: 简化的静态预测策略
- **内联函数**: 高频函数使用内联优化
- **避免虚函数**: 减少间接调用开销

### 编译优化
- **常量折叠**: 编译时计算常量表达式
- **循环展开**: 对小型循环进行展开
- **模板特化**: 为特定类型优化模板函数

## 测试架构

### 测试层次
```
集成测试 (完整程序执行)
    ↓
组件测试 (单个类测试)  
    ↓
单元测试 (单个函数测试)
```

### 测试覆盖
- **指令测试**: 覆盖所有支持的指令
- **边界测试**: 内存和寄存器边界条件
- **异常测试**: 错误处理路径验证
- **性能测试**: 执行效率基准测试

## 代码质量保证

### 编码规范
- **命名约定**: 类名PascalCase，函数名camelCase
- **注释标准**: 使用中文注释说明复杂逻辑
- **格式统一**: 使用4空格缩进，120字符行宽

### 代码审查要点
- **接口设计**: 确保接口简洁明了
- **错误处理**: 验证所有错误路径
- **性能影响**: 评估修改对性能的影响
- **测试覆盖**: 确保新功能有对应测试

## 未来扩展计划

### 短期目标
- **D扩展**: 双精度浮点支持
- **A扩展**: 原子操作指令
- **性能分析**: 添加详细的性能统计

### 长期目标  
- **多核支持**: SMP架构模拟
- **MMU支持**: 虚拟内存管理
- **设备模拟**: 外设和中断支持

---

*该架构文档描述了RISC-V模拟器的整体设计思路和实现细节，为开发者提供代码理解和扩展的指导。*
