# RISC-V模拟器32位到64位升级任务报告

## 任务概述
将当前的RV32I模拟器升级为支持RV64I基础指令集，目标是通过riscv-tests中的rv64ui-p-*测试。

## 当前实施进度 ⭐

### ✅ 已完成阶段

#### 第1阶段：基础类型修改（已完成）
1. **修改types.h** ✅
   - 将 `Address` 从 `uint32_t` 改为 `uint64_t`
   - 添加 `RegValue = uint64_t` 类型定义
   - 添加新操作码：`OP_IMM_32 = 0x1B`, `OP_32 = 0x3B`
   - 添加新Funct3值：`LD = 0x3`, `LWU = 0x6`, `SD = 0x3`

2. **修改CPU接口** ✅
   - 更新 `cpu_interface.h` 中的寄存器访问方法为64位
   - `getRegister()` 返回 `uint64_t`
   - `setRegister()` 接受 `uint64_t`
   - `getPC()` 返回 `uint64_t`
   - `setPC()` 接受 `uint64_t`

3. **修改内存接口** ✅
   - 在 `memory.h` 中添加64位读写方法
   - 实现 `uint64_t read64(Address addr)`
   - 实现 `void write64(Address addr, uint64_t value)`

4. **修改动态指令类** ✅
   - 更新 `dynamic_inst.h` 中所有操作数和结果为64位
   - 修改构造函数参数类型
   - 更新所有相关方法的签名

#### 第2阶段：解码器修改（已完成） 
1. **更新decoder.cpp** ✅
   - 修改 `determineType()` 支持新操作码 `OP_IMM_32` 和 `OP_32`
   - 保持立即数提取为32位（符号扩展在执行时处理）

2. **更新types.cpp** ✅
   - 修改 `initialize_execution_properties()` 支持RV64新指令
   - 添加对LD、LWU、SD指令的内存访问大小设置

#### 第3阶段：执行单元修改（已完成）
1. **修改instruction_executor.h/cpp** ✅
   - 将所有方法签名改为64位参数和返回值
   - 实现64位内存访问指令（LD, LWU, SD）
   - 实现32位算术指令（ADDIW, ADDW, SUBW等）
   - 添加 `executeImmediateOperation32()` 和 `executeRegisterOperation32()`
   - 修改移位指令支持6位移位量（RV64）和5位（W后缀）

2. **修改execute_stage.cpp** ✅
   - 更新ExecutionUnit和CPUState结构为64位
   - 添加对OP_IMM_32和OP_32指令的支持
   - 修改所有地址计算为64位运算

#### 第4阶段：CPU实现修改（进行中 🔄）
1. **修改顺序CPU（cpu.h/cpp）** ✅
   - 将寄存器数组改为 `std::array<uint64_t, NUM_REGISTERS>`
   - 更新PC为64位
   - 修改所有寄存器访问方法为64位
   - 添加 `executeImmediateOperations32()` 方法
   - 更新所有执行方法以支持64位操作

2. **修改乱序CPU（ooo_cpu.h/cpp）** 🔄 进行中
   - 需要更新寄存器访问方法签名
   - 需要修改CPU状态中的寄存器为64位

### 🔄 进行中阶段

#### 第4阶段：CPU实现修改（剩余工作）
- 完成乱序CPU的64位适配
- 确保两种CPU实现的一致性

### ⏳ 待完成阶段

#### 第5阶段：ELF加载器修改
- 修改 `elf_loader.h/cpp` 支持64位ELF文件
- 更新ELF头结构定义
- 修改地址和偏移量类型为64位

#### 第6阶段：测试和调试
- 运行基础测试套件
- 修复发现的问题
- 确保向后兼容性

## 技术实现细节

### RV64I新增指令分析

#### 1. 64位内存访问指令
| 指令 | 操作码 | Funct3 | 描述 |
|------|--------|--------|------|
| LD   | 0x03 (LOAD) | 0x3 | 加载双字(64位) |
| LWU  | 0x03 (LOAD) | 0x6 | 加载字(32位)零扩展 |
| SD   | 0x23 (STORE) | 0x3 | 存储双字(64位) |

#### 2. 32位算术指令（W后缀）
| 指令 | 操作码 | Funct3 | Funct7 | 描述 |
|------|--------|--------|--------|------|
| ADDIW | 0x1B (OP_IMM_32) | 0x0 | - | 32位立即数加法 |
| SLLIW | 0x1B (OP_IMM_32) | 0x1 | 0x00 | 32位逻辑左移 |
| SRLIW | 0x1B (OP_IMM_32) | 0x5 | 0x00 | 32位逻辑右移 |
| SRAIW | 0x1B (OP_IMM_32) | 0x5 | 0x20 | 32位算术右移 |
| ADDW  | 0x3B (OP_32) | 0x0 | 0x00 | 32位加法 |
| SUBW  | 0x3B (OP_32) | 0x0 | 0x20 | 32位减法 |
| SLLW  | 0x3B (OP_32) | 0x1 | 0x00 | 32位逻辑左移 |
| SRLW  | 0x3B (OP_32) | 0x5 | 0x00 | 32位逻辑右移 |
| SRAW  | 0x3B (OP_32) | 0x5 | 0x20 | 32位算术右移 |

### 核心技术要点

1. **寄存器宽度**：所有寄存器改为64位，但x0仍然始终为0
2. **立即数处理**：立即数仍为32位，需要正确符号扩展到64位
3. **W后缀指令**：必须进行32位运算后符号扩展结果到64位
4. **移位量**：RV64使用6位移位量，W后缀指令使用5位
5. **内存对齐**：确保64位访问正确对齐

### 已解决的关键问题

1. **类型转换安全性**：确保32位到64位的正确符号/零扩展
2. **指令解码兼容性**：保持与RV32指令的解码兼容
3. **内存访问统一**：统一64位和32位内存访问接口
4. **执行单元重构**：重构执行逻辑支持两种位宽运算

## 测试计划

### 基础功能测试顺序
1. **基本算术**: addi, add, sub
2. **32位算术**: addiw, addw, subw
3. **内存访问**: ld, sd, lw, lwu
4. **移位操作**: slli, srli, srai, slliw, srliw, sraiw
5. **逻辑运算**: and, or, xor, andi, ori, xori
6. **分支跳转**: beq, bne, blt, bge, bltu, bgeu, jal, jalr
7. **其他指令**: lui, auipc, slt, sltu

### 测试命令
```bash
# 单个测试
python3 run_tests.py --ooo -p "rv64ui-p-addi"

# 批量测试基础指令
python3 run_tests.py --ooo -w 4 -p "rv64ui-p-add*"

# 全部rv64ui测试
python3 run_tests.py --ooo -w 4 -p "rv64ui-p-*"
```

## 当前进度评估 📊

### 完成度：约90%
- ✅ 基础架构修改：100%
- ✅ 指令解码支持：100%  
- ✅ 执行引擎重构：100%
- ✅ CPU实现适配：100%（顺序CPU和乱序CPU都完成）
- ✅ ELF加载器：100%
- ✅ 编译系统：100%
- 🔄 测试验证：50%（存在功能问题需要调试）

### 实际完成工作量：约6小时
- ✅ 乱序CPU适配：2小时
- ✅ ELF加载器修改：1小时  
- ✅ 编译错误修复：2小时
- 🔄 功能测试调试：1小时（进行中）

## 📋 当前测试状态

### RV64I指令测试结果（截至2025年）

#### 乱序CPU测试结果
```bash
# 全部rv64ui测试 (54个测试)
python3 run_tests.py --ooo -w 4 -p "rv64ui-p-*"
```

**测试统计:**
- 总测试数: 54
- ✅ 通过: 32 (59.3%)
- 💥 错误: 22 (40.7%)
- ⏰ 超时: 0 (0.0%)

#### 顺序CPU测试结果
```bash
# 全部rv64ui测试 (54个测试), 测试全部通过！
python3 run_tests.py -w 4 -p "rv64ui-p-*"
```

**乱序CPU测试统计:**
- 总测试数: 54
- ✅ 通过: 28 (51.9%)  
- 💥 错误: 22 (40.7%)
- ⏰ 超时: 4 (7.4%)

### 🟢 成功指令类别
1. **基础算术**: `add`, `addi`, `addw`, `addiw`, `sub`, `subw`
2. **逻辑运算**: `and`, `andi`, `or`, `xor` (部分)
3. **分支指令**: `beq`, `bne`, `bltu`, `bgeu`, `jal`, `jalr`
4. **基础加载**: `lb`, `lbu`, `lh`, `lhu`, `lw`, `lwu`
5. **立即数**: `lui`
6. **部分移位**: `slli`, `srliw`, `srlw` (仅右移有效)

### 🔴 失败指令类别
1. **内存存储**: `sb`, `sh`, `sw`, `sd` 
2. **64位加载**: `ld` - **可能与内存对齐或大小端有关**
3. **立即数运算**: `auipc`, `ori`, `xori` - **可能立即数处理错误**
4. **移位操作**: `sll`, `sllw`, `slliw`, `srl`, `srli`, `sra`, `srai`, `sraiw`, `sraw` - **64位移位实现问题**
5. **比较指令**: `slt`, `slti`, `sltiu`, `sltu` - **部分超时，可能死循环**
6. **内存相关**: `ld_st`, `st_ld`, `ma_data` - **Store/Load转发问题**

### 🔍 问题分析

#### 主要问题类别:
1. **Store Buffer相关**: 所有存储指令失败，疑似Store Buffer在64位适配中存在问题
2. **64位内存访问**: `ld`指令失败，可能内存接口适配不完整  
3. **移位指令**: 大部分左移和算术右移失败，可能移位量处理错误
4. **立即数处理**: `ori`, `xori`, `auipc`失败，可能立即数符号扩展问题

### 📝 调试建议优先级

./risc-v-tests 同样有4个单元测试错误
[  FAILED  ] 4 tests, listed below:
[  FAILED  ] CPUTest.SLT_Instruction
[  FAILED  ] CPUTest.LoadByte_Instruction
[  FAILED  ] CPUTest.LoadStore_Combined
[  FAILED  ] CPUTest.BLT_Instruction

1. 优先调试单元测试的错误
2. **Medium Priority**: 解决Store Buffer在64位下的适配问题  
3. **Low Priority**: 修复乱序CPU的相关问题

### 预计剩余工作量：2-4小时
- Store/Load相关问题修复：1-2小时
- 移位指令问题修复：1小时
- 立即数处理问题修复：0.5小时  
- 全面测试验证：0.5-1小时

## 风险与限制

### 本次实现范围
- ✅ RV64I基础整数指令
- ✅ 64位内存访问
- ✅ 32位算术运算（W后缀）
- ❌ 乘除法扩展（M扩展）- 已升级支持64位
- ❌ CSR指令
- ❌ 原子指令（A扩展）
- ❌ 浮点指令（F/D扩展）

### 潜在问题
1. **性能影响**: 64位运算可能降低模拟器性能
2. **内存使用**: 寄存器文件大小翻倍
3. **兼容性**: 需要确保不破坏现有的32位功能
4. **编译错误**: 大量类型修改可能引入编译错误

## 后续优化建议
1. 添加配置选项支持RV32/RV64切换
2. 实现更多扩展指令集
3. 优化64位运算性能
4. 完善错误处理和诊断信息
5. 添加更全面的测试覆盖