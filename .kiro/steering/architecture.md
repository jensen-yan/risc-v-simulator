# RISC-V 模拟器架构

## 总体架构

RISC-V 模拟器采用**模块化分层架构**，每个组件职责单一、接口清晰。设计遵循以下原则：
- **职责分离**: 每个类专注于特定功能
- **接口抽象**: 组件间通过明确的接口通信
- **可扩展性**: 支持 RISC-V 扩展指令集
- **可测试性**: 便于单元测试和集成测试

## 架构层次

```
┌─────────────────────────────────────────────────────────────┐
│                        用户接口层                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │    main     │  │  调试工具    │  │      测试套件         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                        模拟器控制层                           │
│  ┌─────────────────────────────────────────────────────────┐│
│  │                   Simulator                             ││
│  │    • 程序加载管理                                         ││
│  │    • 执行控制                                            ││
│  │    • 组件协调                                            ││
│  │    • 状态查询                                            ││
│  └─────────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                        核心执行层                              │
│  ┌─────────────┐              ┌─────────────────────────────┐ │
│  │     CPU     │◄────────────►│          Memory             │ │
│  │  • 指令执行  │              │  • 线性地址空间              │ │
│  │  • 寄存器   │              │  • 字节序处理                │ │
│  │  • 状态机   │              │  • 边界检查                  │ │
│  └─────────────┘              └─────────────────────────────┘ │
│         │                                    │                │
│  ┌─────────────┐              ┌─────────────────────────────┐ │
│  │   Decoder   │              │     SyscallHandler          │ │
│  │  • 指令解码  │              │  • 系统调用处理              │ │
│  │  • 格式识别  │              │  • POSIX兼容                │ │
│  │  • 扩展支持  │              │  • I/O重定向                │ │
│  └─────────────┘              └─────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                        基础服务层                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │     ALU     │  │  ElfLoader  │  │      异常处理        │  │
│  │  • 运算操作  │  │  • 文件解析  │  │  • 错误恢复          │  │
│  │  • 比较运算  │  │  • 内存映射  │  │  • 状态报告          │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## 核心组件

### 1. Simulator（模拟器控制器）
- 程序生命周期管理：加载、运行、重置
- 组件协调：统一管理 CPU 和 Memory
- 接口适配：为用户提供简化的高层接口
- 状态监控：提供执行状态和统计信息

### 2. CPU（处理器核心）
- 指令执行：实现完整的取指-译码-执行循环
- 状态管理：维护寄存器和程序计数器状态
- 扩展支持：模块化的指令集扩展机制
- 异常处理：非法指令和内存异常处理

### 3. Memory（内存管理器）
- 地址空间管理：线性 32 位地址空间
- 数据访问：支持字节、半字、字访问
- 字节序处理：统一的小端序实现
- 边界检查：防止内存越界访问

### 4. Decoder（指令解码器）
- 指令识别：区分 16 位压缩和 32 位标准指令
- 字段提取：解析操作码、寄存器、立即数
- 格式转换：将压缩指令扩展为标准格式
- 扩展验证：检查指令是否被支持

### 5. ALU（算术逻辑单元）
- 基础运算：加减法、逻辑运算、移位操作
- 比较运算：有符号/无符号比较
- 类型转换：符号扩展和截断
- 运算优化：高效的位操作实现

### 6. SyscallHandler（系统调用处理器）
- ABI 兼容：实现 RISC-V Linux ABI 规范
- I/O 重定向：处理标准输入输出
- 资源管理：简化的内存和文件管理
- 测试支持：为 riscv-tests 提供专门支持

### 7. ElfLoader（ELF 文件加载器）
- 格式解析：解析 ELF 文件头和程序头表
- 内存映射：将程序段加载到正确的内存位置
- 权限设置：处理段的读写执行权限
- BSS 初始化：零初始化未初始化数据段

## 数据流架构

### 程序执行流
```
用户程序 → ElfLoader → Memory ← CPU → Decoder
                                ↓
                        SyscallHandler ← ALU
```

### 指令执行流
```
Memory::fetchInstruction() → Decoder::decode() → CPU::execute*Type() → ALU/Memory操作
```

### 系统调用流
```
ECALL指令 → CPU::handleEcall() → SyscallHandler::handleSyscall() → 具体处理函数
```

## 扩展机制

模拟器支持通过扩展标志位启用不同的指令集扩展：

```cpp
enum class Extension : uint32_t {
    I = 0x1,    // 基础整数指令集
    M = 0x2,    // 乘除法扩展
    F = 0x4,    // 单精度浮点扩展
    C = 0x8     // 压缩指令扩展
};
```

添加新扩展的步骤：
1. 在 `Extension` 枚举中添加新标志
2. 在 `Decoder` 中添加识别逻辑
3. 在 `CPU` 中添加执行函数
4. 在 `validateInstruction` 中添加检查
5. 更新测试用例